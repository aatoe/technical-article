### 解构赋值

**解构赋值**语法是一种 Javascript 表达式。通过**解构赋值,** 可以将属性/值从对象/数组中取出,赋值给其他变量。

解构赋值用得好,也是一种修养,我发现MDN已经写的非常的详细了,但是他也有一些没有说到的,我这个主要是加强一下自己的熟悉度吧和进行一点补充~~以下是MDN的解构赋值的URL

<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment>

`数组解构:` “模式匹配”,只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，如果匹配不成功变量的值就等于undefined

```js
我们以前比较low的写法
let foo = [1,2,3];
let a = foo[0];
let b = foo[1];
let c = foo[2];
//上面这种麻烦,low,不优雅.

let foo = ["one", "two", "three"]; 
let [one, two, three] = foo; 
//首先声明一下这些变量,接着进行模式匹配 两边都是数组 按照顺序对应起来,如果匹配不成功变量的值就等于undefined
console.log(one); // "one"
console.log(two); // "two"
console.log(three); // "three"
```

`对象解构`:

```js
let ab = {a:1,b:2};
let a = ab.a;  //1
let b = ab.b;  //2
//上面这种麻烦,low,不优雅.

let cd = {c:3,d:4};
let {c,d} = cd;
//首先声明一下这些变量,接着进行模式匹配,两边都是对象,变量必须与属性同名才能取到正确的值,这一点区别于数组
console.log(c);
console.log(d);
```

其实还有很多解构赋值的方式,总之能帮我简化代码的我们就采用,不能的话,那么就还是老老实实的写,避免可读性变差.

### 迭代和递归的区别

迭代可以转换为递归，但递归不一定可以转换为迭代。

采用递归算法需要的前提条件是，当且仅当一个存在预期的收敛时，才可采用递归算法，否则，就不能使用递归算法。

|      | 定义                               | 优点                                                         | 缺点                                                         |
| ---- | ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 递归 | 程序调用自身的编程技巧称为递归     | 1）大问题化为小问题,可以极大的减少代码量；2）用有限的语句来定义对象的无限集合.；3）代码更简洁清晰，可读性更好 | 1）递归调用函数,浪费空间；2）递归太深容易造成堆栈的溢出      |
| 迭代 | 利用变量的原值推算出变量的一个新值 | 1）迭代效率高，运行时间只因循环次数增加而增加；2）没什么额外开销，空间上也没有什么增加， | 1） 不容易理解；2） 代码不如递归简洁；3） 编写复杂问题时困难。 |

二者之间的关系  : 1） 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。2） 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出.

迭代例子:

```js
//迭代实现斐波那契数列
function fab_iteration(num){  
	if (num == 1 || num == 2) {
        return 1;
    }
    else {
        let f1 = 1;
        let f2 = 1;
        let f3 = 0;
        for (let i = 0; i < num - 2; i++) {
            f3 = f1 + f2; //利用变量的原值推算出变量的一个新值  
            f1 = f2;
            f2 = f3;
        }
        return f3;
    }  
}
console.log(fab_iteration(3)); //2
//我们的for while forEach Map 等等都是用迭代写的.原因就是相比于递归当数据比较复杂的时候,不会浪费太多的栈空间.
```

递归例子:

```js
//递归实现斐波那契数列  
function fab_recursion(num) {
    if (num == 1 || num == 2) {
        return 1;
    }
    else {
        return fab_recursion(num - 1) + fab_recursion(num - 2);    //递归求值  
    }
}
console.log(fab_recursion(3)); //2
```

### 赋值和浅拷贝深拷贝的区别

谈论到这个话题就是涉及到数据类型,简单的数据类型就是除了复杂数据类型对象,数组,函数都是属于简单的数据类型,那么他们的区别就是简单的数据类型就放在栈空间,而复杂数据类型是放在堆空间,在栈空间会存放一个引用.

<font color="red">那么讨论的就要分为简单的数据类型和复杂的数据类型</font>

#### 赋值

​	简单的数据类型

```js
// 这里简单的数据类型我用字符串来举例子
let a = "Atoe";
let b = a;
console.log(a===b); // true	
b = "12";
console.log(a===b); // false 
// 解释其实很简单,首先 "Atoe"在栈里面开了一个空间,然后赋值给了a,a又赋值给了b,他们a,b这两个变量都是指向 同一个栈空间.
// 接着下面 "12"在栈里面创建了一个存放"12"的空间,然后赋值给了b. 好了结束
```

​       复杂数据类型

```js
// 这里的复杂数据类型我用对象
let aObj = {name:"atoe"};
let bObj = aObj;
console.log(aObj===bObj);  //true 

bObj.age = 22;
console.log(aObj===bObj); // true
console.log(aObj,bObj)    // {name: "atoe", age: 22},{name: "atoe", age: 22}

// 解释 {name:"atoe"}是一个复杂的数据类型,然后再对空间创建了一个空间来存放这个对象,又在栈空间创建了一个地址,这个地址指向这个对象,接着把这个地址赋值给aObj.aObj又赋值给bObj.所以他们的指向都是同一个对象,那么当然是全等.
//第二个,当我们在bObj里面添加属性age的时候,我们改变了bObj,但是bObj改变了是堆空间的对象,那么造成的原因就是aObj也跟着改变. 所以他们都是全等. 赋值解释清楚了
```

#### 浅拷贝

首先明白拷贝无论深浅都是针对复杂的数据类型来说的,简单的数据类型是没有的

那么什么叫浅拷贝呢?

浅拷贝就是被赋值要好一点,比深拷贝差一点. 那么怎么理解这家白话呢,就是"浅", 他只拷贝了对象的第一层,往后面的层都是赋值.(我没有解析的太清晰,代码见)

```js
let arr = [11,{name:"Atoe"},"123"];
let newArr = arr.slice(0,3); //[11,{name:"Atoe"},"123"]; 把0到3之间的内容切出来(不包含3),返回.
console.log(arr===newArr); // false

// 来,数组是复杂数据在堆创建空间,然后栈里面有一个引用赋值给arr, 下面,slice这个方法是对数组的一个切片,不会改变原来数据,返回一个新的数组,那么这里我切的是整个数组,然后让他们===,结果返回false,其实他们的数据类型,值都是一摸一样的,但是就是false,首先===(全等符所有的都比较,不符合就是flase).那么现在我们知道了arr和newArr不是一样的东西.是不是属于拷贝.但是我们不知道是深还是浅拷贝.
// 验证深浅拷贝
newArr[1].name = "果汁冰";
console.log(arr,newArr);
//  [11,{name:"果汁冰"},"123"],[11,{name:"果汁冰"},"123"]
//好了,这是我要说的点了,为什么改变了newArr这个数据同时也会改变arr,不是说他们完全没有关系吗?
//我一一说来:这就是所谓的浅拷贝,浅字就是值拷贝第一层(表层)的东西,如果第一层是有复杂数据类型拷贝的只是引用,
//那么就是说arr和newArr里面的{}对象就是一直是拷贝的是引用,你到时候改变他的时候还是回去堆空间找到真正的值改变他,所以改变newArr中的复杂对象的值也会影响到arr.
console.log(arr[1]===newArr[1]); // true 这个是不是验证我说的话? 复杂数据类型是不是相当于简单的赋值而已..
//继续验证 里面的简单数据类型是赋值,重新赋值不会改变另外一个对象的简单数据类型
newArr[0] =22
console.log(arr,newArr);
//  [11,{name:"果汁冰"},"123"],[22,{name:"果汁冰"},"123"]
// 是不是不会影响另外一个,以上是我想表达的浅拷贝的意思.

//还有一点就是数据对象有很多方法都是浅拷贝哦.可以去玩一下.splice 什么的
```

#### 深拷贝

深拷贝的意思就是复制出一个和真的一模一样的东西出来,不是高仿鞋,是真的.只不过他们存放的空间地址不是一样的.

​	实现深拷贝

​	最low的

```js
let arr = [11,{name:"Atoe"},"123"];
let newArr =  JSON.parse(JSON.stringify(arr));
console.log(arr,newArr); //[11,{name:"Atoe"},"123"] [11,{name:"Atoe"},"123"];\
console.log(arr===newArr);// false 
console.log(arr[1]===newArr[1]); // false
//那还需要解释吗?两个完全不一样的东西了,这是比较简单的深拷贝的方法,
//但是缺点贼多,不能拷贝 方法,undefined,...忘了.有空回来补上,但是实际用还是够用的
//原理就是序列化,先变为字符串,简单数据类型在栈空间,然后转为对象,在堆中创建了一个新的对象,所以呢,就不会和之前的有半毛钱的关系了.
```

### 关于this

我们一开始解释this的时候,肯定会有点困得,就是觉得怎么有时候力不从心,感觉不是真正学会.

分为四个方面,优先级越往下越高

- 默认绑定
- 隐式绑定
- 显示绑定
- new关键字

#### 默认绑定

默认绑定的优先级最低,就是后面的都可以去替换他.那么就只要一个window.在严格模式不会出现默认绑定.
我慢慢解释.

```js
function foo(){
    console.log(this.a) // 这个this是指向window.因为在最外层,那么var声明变量是直接放在window的属性上面,所以当去访问他的属性的时候,可以访问到a.但是当我们es5上使用"use strict"的话,将不会存在window,因为这时的最外层对象是undefined就是不存在,所以会报错.
}
var a = 1;
foo();
```

#### 隐式绑定

隐式绑定发生在对象.在对象上面会有隐式绑定.

```js
var obj = {
	name : "Atoe",
    age : 22,
    method : foo
}
function foo(){
    console.log(this)  //this 指向obj
    console.log(this.age) // 22
}
obj.method();  //这里验证了那句,谁调用我就,我就指向谁.

//我要变了.
var myMethod = obj.method; // 将obj.method的属性值是一个foo函数 赋值给myMethod,
myMethod();// 此时myMethod就是foo函数的一个引用,当调用的时候没有出现任何修饰符,那么就是默认绑定,是window.这种情况就出来的丢失隐式绑定
所以他打印的结果是: window undefined.
或许你理解不了,我或许可以提供一个思路给你,就是真正调用的时候利用对象(这里的是obj)点语法点出来的,那么他的this指向obj.
```

#### 显式绑定

显式绑定就是通过我们自己来改变他的this指向,我们通常利用call apply bind 来改变this的指向.这三者的区别不大.call(this,只接收一个个的参数,按照顺序接收),apply(this,[接收一个数组,把参数都放进去]) bind(this,参数和call是一样的,但是区别就是bind只会生成一个新的指向函数,不会去执行,call,apply都会去执行)

回到主题

```js
// 当我们想让this的指向方向改变,或者不受外界隐式应该使用显式绑定
比如刚刚上面的
var obj = {
	name : "Atoe",
    age : 22,
    method : foo
}
  function foo(){ 
      //当每次调用foo的时候,我在函数内部将this的指向指向了我希望的obj上面,你外面怎么改也是没有用的.
           bar.call(obj); // 这里是会去执行的bar这个函数.
           function bar(){
            console.log(this)
            console.log(this.age)
      }
  }

obj.method();  //obj 22

//我要变了.
var myMethod = obj.method; // 将obj.method的属性值是一个foo函数 赋值给myMethod,
myMethod(); // obj 22
```

#### new绑定

优先级最高的new绑定.什么时候用到呢?当我们 var foo = new Foo(); 就用到了

- 创建一个全新的对象
- 新对象指向构造函数调用的原型
- 新对象的this构造函数调用的this
- 返回一个对象