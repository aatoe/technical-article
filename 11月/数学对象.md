# Math

**Math** 是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。

拿来即用,不需要构造(实例化)出来.

文章结构大致跟一位掘金大佬的一样,进行一些删减



> #### 三角函数

我们发现MDN上面都介绍了特别多的Math对象下面的方法,但是用的真不多,我个人觉得在我的职业生涯目前还看不到用处.

```js
Math.sin(x)  // 返回x的正弦值
Math.cos(x)  // 返回x的余弦值
Math.tan(x)  // 返回x的正切值 
...等等太多了.用处都不大.
```



> #### 数学运算方法

```js
Math.sqrt(x) // 返回x的平方根 根号x
Math.pow(x,y) // 返回x的y次幂,如果y未初始化,则返回x 
...等等太多了.用处都不大.
```



> #### 数值运算方法

```js
Math.abs(x)  // 返回x的绝对值
Math.floor(x) // x向下取整
Math.ceil(x) // x向上取整
Math.trunc(x) // 返回x的整数部分
Math.fround(x) // 当x有小数的时候,返回离它最近的当精度浮点数形式的数据 x12323 x=(1.2)类似这样的
Math.min(x,y,z) // 返回x,y,z中的最小值 不接受其他参数的形式(必须单独的分开)
// 1.那么他不接受其他形式的参数我们总有办法的.Math.min.apply(null,[x,y,z]).很多时候都可以通过这种手段来传参.
// 2.不传参就是返回Infinity
Math.max(x,y,z) // 返回x,y,z中的最大值,不接受其他参数的形式(必须单独的分开)
// 1.不传参就是返回-Infinity
Math.random() // 返回0 ~ 1 之间的随机数
Math.sign(x) // x为返回5个值(1(正数),0(正0),-0(负0) -1(负数) NaN(非数字类型))
Math.round(x) // 四舍五入
```

补充 : Number 类型的数值运算方法

这个方法我们公司的后端用得老溜了,当时还是第一次在他们维护的jsp页面看见的,哈哈.

Number .prototype中有一个方法是toFixed() , 用于将数值转换为指定小数位数的形式

`toFixed(x) 小数点后x位进行四舍五入运算`

```js
let num = 123.232131;
console.log( num.toFixed()); // 123 等同于num.toFixed(0)
console.log( num.toFixed(1)); // 123.2
```





## 位运算

我们的Math对象可以进行数学运算原理就是位运算,那么还多了一个转换的步骤,效率更高的当然回归本源,

所以算法大多使用位运算,然后位运算都是二进制,二进制全是0跟1,嗯,到头了.

前提:位运算不会把小数纳入计算范围,那么当小数需要计算的时候,有些时候会导致精度的丢失.那么位运算没有讲这个考虑.应该是由其他的方法来实现的.涉及到计算机原理吧

####  按位与(&)

```js
比如 16用二进制表示 1111 和用1二进制表示 0001,遇到 对应的位,两边都是1 才返回1,否则返回0.
 15:1111
结果:0001===> 0001 ==>1
  1:0001
那么按位与& 他有种向小变化的趋势. 

// console.log(5.2&5.2); // 5 总之5.x &5.x都是等于5
// console.log(15 & 1); // 1 解释就在上面
```

#### 按位或(|)

```js
比如 15用二进制表示 1111 和用1二进制表示 0001,遇到 对应的位,只要一边为1 就返回1.
 15:1111
结果:11111===> 1111 ==>15
  1:000
那么按位或| 他有种向大变化的趋势. 
// console.log(15 | 1); // 15 上面解释
// console.log(5.1|6.1); // 7
  5:0101
结果:0111 ==> 7
  6:0110
```

#### 按位非(~)

当前数值取反再-1

```js
~x === -x-1 ===> ~2019 === -2019 -1 ==> -2020
~~x === -(-x-1) -1 ===> ~~2019 === - (-2019-1) -1 ===> 2019

console.log(~2019); // -2020
console.log(~~2019); // 2019
console.log(~~2019.123); // 2019
```

#### 按位异或(^)

^运算符连接的两个数, 它们二进制补码形式的值每位参与运算, 只有相对应的每位值不同, 才返回1, 否则返回0.

> 有人比作是消消乐,相同就是消去为0.不同显示为1. 特别恰当

```
比如 16用二进制表示 1111 和用1二进制表示 0001,遇到 对应的位,两边不相同(两边一定是0和1各一边)才返回1,否则返回0(都是0或者都是1).
 15:1111
结果:1110===> 1110 ==>14
  1:0001
那么按位异或^ 很多规律需要慢慢总结吧.
 console.log(15 ^ 1); // 14
```

**位运算小总结**

**运算(&|~^)可用于取整, 同 Math.trunc().**



#### 有符号左移(<<)

当前的数值,除了符号向左按照二进制移动

```js
x << y ===> x 往左移动y位
start    3: 0011
end 左移2位:001100 : 12(不管你前面补多少0都是12的呀.)
console.log(3 << 2);  // 12
console.log(2 << 3)=== console.log(Math.pow(2, 4)); // 16 
// 得出规律 2 << n === Math.pow(2,n+1)
```

#### 有符号右移(>>)

```js
x >> y ===> x往右移y位
start    5: -0101
end 右移2位:-01.01 : -2(小数点后面不用管的)
console.log(-5 >> 2); // -2
console.log(-5 >> 2) ===console.log(Math.floor(5*Math.pow(2,-1)));
x >> y ===Math.floor(x*Math.pow(2,-n))

```

